---
title: "Activity Budget Analysis"
author: "Cali Wilson"
date: "5/20/2022"
output: html_document
---
# How does urbanization influence ibis behaviors relevant to transmission? 

### Specifically, how does variation in flock size and frequency of provisioning influence these behaviors? 

#### Data:

10-minute focal follow observations of birds at 5 urban parks in South Florida. Follows conducted during summer 2019.

**Focal follows were only conducted in urban parks** 

Note: Focal follows were **only** conducted when people were not actively feeding the birds so foraging means probing on the ground for food. The few instances of consuming human provided food are cases where ibis were foraging 'naturally' and happened upon scraps of anthropogenic food that was already on the ground. 


##### Sample Sizes / Data Structure

Observations consist of 168 focal follows lasting > 2 minutes. Five urban parks were samples for ~30 focals per site. Sites were visited 2-4 times each. 

**Provisioning estimates:** Each visit, # of people and groups feeding birds were recorded for duration of visit. Provisioning was estimated by counting the number of groups that fed the birds per visit and dividing by total time I was at the site to get **# provisioning events/ hour**. Each focal follow was paired with the average # of provisioning events per hour on day/site of the focal follow.  

**Flock size estimates:** Every ~30 minutes, flock size was recorded. I paired each focal follow with the nearest estimate of flock size. 

```{r Load Packages, message=FALSE, warning=FALSE, include=FALSE}

#Load packages
library(readxl)
library(dplyr)
library(tidyr)
library(reshape2)
library(ggplot2)
library(lubridate)
library(skimr) 
library(gridExtra)
library(Hmisc) 
library(viridis)
library(FSA)
library(MASS)
library(glmmTMB)
library(DHARMa)
library(bbmle) 
library(data.table)
library(mosaic)  # standardizing variables
library('ggeffects') #plotting glmmTMB predicted values
library(AICcmodavg) #model selection tables
library(kableExtra)
```

```{r Set Directory and load data, message=FALSE, warning=FALSE, include=FALSE}
#Read in data----
behav<-read_excel("data/Summer 2019 Field Data.xlsx", 
                  sheet = "behaviorsTable") #activity budgets
behav$activity2 <- paste(behav$Activity, behav$Location) #combine two levels of behavior types
focTable_all<- read_excel("data/Summer 2019 Field Data.xlsx", 
                          sheet = "focalsTable") #read in 'focTable' to get the end focal times 
groupsize<-read_excel("data/Summer 2019 Field Data.xlsx", 
                      sheet = "Flock Composition")
people<- read_excel("data/Summer 2019 Field Data.xlsx", 
                    sheet = "People Feeding")

flockcomp<- read_excel("data/Summer 2019 Field Data.xlsx", 
                    sheet = "Flock Composition")

focTable <- dplyr::select(focTable_all, device_ID, session_start_timeStamp,focal_start_timeStamp,focal_end_timeStamp) #select relevant columns

behav <- merge(behav, focTable, by=c("device_ID", "session_start_timeStamp", "focal_start_timeStamp")) #add end times to behav dataframe; the length should be the same as 'behav' but with 1 extra variable

proximity<- read_excel("data/Summer 2019 Field Data.xlsx", 
                       sheet = "proximity") #read in 'proximity' to get site names
```

```{r data wrangling, message=FALSE, warning=FALSE, include=FALSE}
proximity <- dplyr::select(proximity, site, actor=focalID)
proximity <- unique(proximity) 
behav <- merge(behav, proximity, by=c("actor")) #add site name to behav

behav2 <- dplyr::select(behav,site,actor,Observer,device_ID,session_start_timeStamp,focal_start_timeStamp,behavior_timeStamp,focal_end_timeStamp,Activity,Location,activity2,Notes1=Notes,Notes2=...19,Notes3=...20) #remove irrelevant variables and modify note names to clean up data

behav2$focalID <- as.character(paste(behav2$device_ID, behav2$focal_start_timeStamp, sep = "")) #create unique code 'focalID' for each observation 
event <- as.data.frame(subset(behav2, Activity == "Defecation" | Activity == "Socialization")) #separate 'event' behaviors for other analysis
behav2 <- behav2[behav2$Activity!='Defecation' & behav2$Activity!='Socialization', ]#remove 'event' behaviors where duration doesn't make sense

#there is one focal follow at MCD (indiv MCD33) where an activity button was pressed 1 second after the focal ended (iPad glitch) this messes up proportions by 1 second for this focal later on. To fix this, we need to remove row if behavior_timeStamp is after focal_end_timeStamp. 
behav2$problem<-behav2$behavior_timeStamp>behav2$focal_end_timeStamp #TRUE indicates a problem

behav2<-behav2[behav2$problem != TRUE, ] #remove observations where TRUE

#Turn 'behav2' raw data into activity budgets with proportions for activities with duration---- 
subsetFocals <- function(behav2, focalID){
  subset <- behav2[behav2$focalID,]
  return(subset)
}

summarizedData <- data.frame()
listFocalIDs <- unique(behav2$focalID)
for(i in 1:length(listFocalIDs)){
  focal <- subset(behav2, focalID==listFocalIDs[i])
  focal <- focal[order(focal$behavior_timeStamp),] 
  focal$PrevBehav <-lag(focal$activity2) #make column with previous behavior
  focal$PrevBehav[1] <- "firstBehav" #give first column a value since it wont have a previous behav
  focal <- focal[which(!focal$activity2==focal$PrevBehav),] #delete duplicates
  focal$start <- focal$behavior_timeStamp #create start variable
  focal$stop <- lead(focal$behavior_timeStamp) #create stop variable
  focal$stop <- ifelse(is.na(focal$stop), focal$focal_end_timeStamp, focal$stop)
  focal$start <- ymd_hms(focal$start)
  focal$stop <- ymd_hms(focal$stop) 
  focal$duration <- difftime(focal$stop, focal$start) #the duration is in seconds
  focal$duration <- as.numeric(focal$duration) #change to numeric
  focal$duration<-ceiling(focal$duration) #round behavior duration to nearest second
  focal$focalduration <- sum(focal$duration, na.rm = TRUE) #create column with focal duration
  focal$focalduration <- ceiling(focal$focalduration)#round duration to nearest second
  focal$activity_proportion <- focal$duration/focal$focalduration #create proportion
  focalID <- focal$focalID
  activity <- focal$activity2
  activity_proportion <- focal$activity_proportion
  actor <- focal$actor
  site <- focal$site
  focalduration <- focal$focalduration
  activityduration <-focal$duration
  start <-focal$start
  stop <- focal$stop
  summarizedRow <- cbind.data.frame(site, activity, activity_proportion, actor, focalID,focalduration, activityduration, start, stop)
  summarizedData <- rbind(summarizedData, summarizedRow)
}

#only keep focals with duration greater than or equal to 120 seconds
summarizedData<- summarizedData[summarizedData$focalduration >=120, ]

sumofActivityProps <-aggregate(x=summarizedData$activity_proportion, #add activities types together by focal ID 
                                by=list(summarizedData$activity, summarizedData$focalID), #sum all all activity proportions by individual follow
                                FUN=sum) 
names(sumofActivityProps)[names(sumofActivityProps) == "Group.1"] <- "Activity" 
names(sumofActivityProps)[names(sumofActivityProps) == "Group.2"] <- "focalID" 
names(sumofActivityProps)[names(sumofActivityProps) == "x"] <- "activity_proportion" 



#add sites back in from 'behav2'
behav3 <-dplyr::select(behav2, site,Observer, focalID) #modify behav2 to add back in site and observer
behav3 <- unique(behav3) #remove duplicate rows before merging
activityProps_byindividual <- merge(sumofActivityProps, behav3, by="focalID") #merge data frames 

#Data will look weird unless 0's are added to focal follows where certain behaviors do not occur
transposing <-spread(activityProps_byindividual, key=Activity, value=activity_proportion, fill="0" )#spread the data to include 0's
activityProps_byindividual2 <-melt(transposing, id.vars=c("focalID", "site","Observer")) #melt it back together in the correct format
names(activityProps_byindividual2)[names(activityProps_byindividual2) == "variable"] <- "Activity" #rename column
names(activityProps_byindividual2)[names(activityProps_byindividual2) == "value"] <- "activity_proportion" #rename column
activityProps_byindividual2$activity_proportion <- as.numeric(activityProps_byindividual2$activity_proportion)

#add in focal start time so we have time of day measurement:
#This can be done using the focalID because this variable was creating by merging device ID and focal start time
activityProps_byindividual2$dat_time <- substr(activityProps_byindividual2$focalID, start=37, stop=55)
activityProps_byindividual2$date <- substr(activityProps_byindividual2$dat_time, start=1, stop=10)
activityProps_byindividual2$time <- substr(activityProps_byindividual2$dat_time, start=12, stop=19)

#add in band numbers if known..
focTable2 <- dplyr::select(focTable_all, device_ID, focal_start_timeStamp,Band_Num)
focTable2$focalID <- as.character(paste(focTable2$device_ID, focTable2$focal_start_timeStamp, sep = ""))
focTable2 <- dplyr::select(focTable2,focalID,Band_Num)
activityProps_byindividual2 <- merge(activityProps_byindividual2, focTable2, by="focalID")
indiv_ab <- activityProps_byindividual2 #rename to shorter df

#bin time into specific times of day
timeBin <- function(x) { 
  if(x<=10) y <- "before 10am"
  if(x > 10 & x <= 12) y <- "10am-12pm"
  if(x > 12 & x <=14) y <- "12pm-2pm"
  if(x > 14) y <- "after 2pm"
  return(y)
}

indiv_ab$ToD <- sapply(indiv_ab$time,timeBin) 
indiv_ab$ToD <- factor(indiv_ab$ToD, levels = c("before 10am", "10am-12pm", "12pm-2pm", "after 2pm"))

#add in group size data------
groupsize <- dplyr::select(groupsize, date, time,site,WHIB_total)

groupsize$time <- as.character(groupsize$time)
groupsize$time <- substr(groupsize$time, start=12, stop=19)
groupsize$ToD <- sapply(groupsize$time,timeBin) 
groupsize$ToD <- factor(groupsize$ToD, levels = c("before 10am", "10am-12pm", "12pm-2pm", "after 2pm"))
groupsize$date <- as.character(groupsize$date)

avgWHIB <- aggregate(x=groupsize$WHIB_total,
                     by=list(groupsize$date,groupsize$ToD, groupsize$site), FUN=mean)  #now averge whib_total by ToD, date, and site
names(avgWHIB)[names(avgWHIB) == "Group.1"] <- "date" #rename
names(avgWHIB)[names(avgWHIB) == "Group.2"] <- "ToD" #rename
names(avgWHIB)[names(avgWHIB) == "Group.3"] <- "site" #rename
names(avgWHIB)[names(avgWHIB) == "x"] <- "meanWHIB" #rename

indiv_ab <- merge(indiv_ab, avgWHIB, by=c("date", "ToD", "site")) 

#Add in people feeding data----
people <- na.omit(people) #omit rows with NAs
#Fix time and date variables: 
people$arrive <- as.character(people$arrive) 
people$arrive <-substr(people$arrive, 12,19) #remove date (first 11 characters, keep 12-19)
people$depart <- as.character(people$depart) #convert to character so we can remove date
people$depart <-substr(people$depart, 12,19) #remove date (first 11 characters, keep 12-19)
people$date <- as.character(people$date) #make this a character so it stays correct
people$arriveTD<- as.character(paste(people$date, people$arrive , sep = " "))
people$departTD<- as.character(paste(people$date, people$depart , sep = " "))
people$arriveTD <-ymd_hms(people$arriveTD,tz="EDT") #convert time and date to something numeric for duration calculation
people$departTD <-ymd_hms(people$departTD,tz="EDT")#convert time and date to something numeric for duration calculation
people$durationMIN <- difftime(people$departTD, people$arriveTD, units = ("mins"))
people$durationMIN <- as.numeric(people$durationMIN) #convert to numeric
people$durationHR <- difftime(people$departTD, people$arriveTD, units = ("hours"))
people$durationHR <- as.numeric(people$durationHR) #convert to numeric
people$number_indiv_feeding <- as.numeric(people$number_indiv_feeding)
people$groups_feeding <- as.numeric(people$groups_feeding)

avgduration <- aggregate(x=people$durationHR, by=list(people$date,people$site), FUN=sum) 
names(avgduration)[names(avgduration) == "Group.1"] <- "date" 
names(avgduration)[names(avgduration) == "Group.2"] <- "site" 
names(avgduration)[names(avgduration) == "x"] <- "durationHR" 

avgindiv <- aggregate(x=people$number_indiv_feeding, by=list(people$date,people$site), FUN=sum) 
names(avgindiv)[names(avgindiv) == "Group.1"] <- "date" 
names(avgindiv)[names(avgindiv) == "Group.2"] <- "site" 
names(avgindiv)[names(avgindiv) == "x"] <- "no.indiv" 


avgevents <- aggregate(x=people$groups_feeding, by=list(people$date,people$site), FUN=sum) 
names(avgevents)[names(avgevents) == "Group.1"] <- "date" 
names(avgevents)[names(avgevents) == "Group.2"] <- "site" 
names(avgevents)[names(avgevents) == "x"] <- "avgevents" 

feeding <- merge(avgindiv, avgduration, by=c("date","site")) 
feeding <- merge(feeding, avgevents, by=c("date","site")) 

feeding$no.people.per.hour <- feeding$no.indiv/feeding$durationHR
feeding$events.per.hour <- feeding$avgevents/feeding$durationHR

indiv_ab2<- merge(feeding, indiv_ab,all.y = TRUE, by=c("date","site")) #use all.y=TRUE to add NAs where we don't have people feeding counts 

#how should I reduce the number of variables? 
unique(indiv_ab2$Activity) #too many variables 
ab_summary<- dplyr::select(indiv_ab2,focalID, site, ToD, activity=Activity,prop=activity_proportion)
s<-spread(ab_summary, key = activity, value = prop)


#would like to know how many obs > 0 for each variable, create fxn to do this in skimr
N.greaterthan0 <- function(column) {
  greaterthan0 <- sum(column > 0)
  
  paste0(greaterthan0)
}


my_skim <- skim_with(numeric = sfl(greaterthan0=N.greaterthan0,median,p0 = NULL,p25=NULL,p50=NULL,p75=NULL,p100=NULL,hist=NULL)) #descriptive stats for each variable 

s.sum.all<- s %>%my_skim %>% yank("numeric")  #all variables of class numeric

s.sum.site<- s %>% 
  dplyr::group_by(site) %>%  #all variables by site
  my_skim  %>%
  yank("numeric") #just numeric variables

#png("sum.all.png", height = 50*nrow(s.sum.all), width = 200*ncol(s.sum.all))
#grid.table(s.sum.all)


#png("sum.bysite.png", height = 22*nrow(s.sum.site), width = 190*ncol(s.sum.site))
#grid.table(s.sum.site)
#dev.off()

#s%>%
 # dplyr::select_if(is.numeric) %>% hist.data.frame() #histograms - big plot that throws errors due to margin size (expand boxes if you want this plot)

#Group together certain variables
fillcolumn <- function(x) { 
  if(x=="Foraging soil") y <- "Foraging"
  if(x=="Foraging water") y <- "Foraging"
  if(x=="Foraging HO") y <- "Foraging"
  if(x=="Foraging Hfood") y <- "Foraging"
  if(x=="Grooming Preening") y <- "Grooming"
  if(x=="Grooming Bathing") y <- "Grooming"
  if(x=="Disturbance Response Flush") y <- "Disturbance"
  if(x=="Disturbance Response Retreat") y <- "Disturbance"
  if(x=="Drinking NA") y <- "Drinking"
  if(x=="Flying NA") y <- "Flying"
  if(x=="Loafing Asleep/Resting") y <- "Asleep/Resting"
  if(x=="Loafing Vigilant") y <- "Vigilant"
  if(x=="Walking on HO") y <- "Walking"
  if(x=="Walking on pavement") y <- "Walking"
  if(x=="Walking on soil/grass") y <- "Walking"
  return(y)
}
ab_summary$act_type <- sapply(ab_summary$activity,fillcolumn) 
head(ab_summary)

grouped_summary<-ab_summary %>% 
  group_by(focalID, act_type) %>% 
  summarise(prop.new = sum(prop, na.rm = TRUE))

checking<-grouped_summary %>% #check to make sure all props sum to 1
  group_by(focalID) %>% 
  summarise(prop.new2 = sum(prop.new, na.rm = TRUE))


ifelse(checking$prop.new2 > 1.00000000000,checking$focalID,NA) #something weird is happening




ggplot(data=grouped_summary, aes(x=focalID, y=prop.new, fill=act_type)) +
  geom_bar(stat="identity") +
  scale_fill_viridis(discrete=TRUE)+ ylab("Proportion of Time")+ xlab("Focal Follow") #checking all proportions add to 1

all_urban<-grouped_summary %>% 
  group_by(act_type) %>% 
  summarise(prop.new = mean(prop.new, na.rm = TRUE))
sum(all_urban$prop.new) #confirm props add to 1

```

```{r urban follows graphic, echo=FALSE, message=FALSE, warning=FALSE}
ggplot(data=all_urban, aes(x="", y=prop.new, fill=act_type)) +
  geom_bar(stat="identity") +
  scale_fill_viridis(discrete=TRUE) + ylab("Proportion of Time")+ xlab("All urban follows")

#tapply(grouped_summary$prop.new, grouped_summary$act_type, summary) 

```

Birds seem to spend the most time foraging, grooming, and being vigilant. 

I am going to re-group these variables according to their relevance to different modes of parasite transmission (see different sections below). 

```{r isotope data, eval=FALSE, message=FALSE, warning=FALSE, include=FALSE}
##isotope data----

isotope <- read_excel("data/murryetal2018philtrans_isotope.xlsx")

isotope <- as.data.frame(subset(isotope, Site == "Indian Creek" | Site == "Dreher Park"| Site == "Gaines Park"| Site == "Juno Beach"))

ggplot(isotope, aes(x=Site, y=d15N)) + 
  geom_boxplot()  + ylab("d15N")

ggplot(isotope, aes(x=Site, y=d13C)) + 
  geom_boxplot()  + ylab("d13C")

ggplot(isotope, aes(x=d13C, y=d15N, shape=Site, color=Site)) +geom_point()
```



```{r flock size, message=FALSE, warning=FALSE, include=FALSE}
##add in flock size-----
flocksize<- dplyr::select(flockcomp,date,site,time,WHIB_total)
flocksize$date<-as.character(flocksize$date)
flocksize$date <- substr(flocksize$date, start=1, stop=10)
flocksize <- subset(flocksize, site == "ICP" | site == "DP"| site == "GP"| site == "JB"| site == "MCD")
ggplot(flocksize, aes(x=site, y=,WHIB_total)) + 
  geom_boxplot()  + ylab("White Ibis Flock Size")+ ggtitle("Plot of white ibis flock sizes recorded at each site")

flocksize.bydate<- flocksize %>% 
  dplyr::group_by(site,date) %>% summarise(size=mean(WHIB_total))

##instead of average flock size, look at nearest flock size taken at time nearest to focal follow
head(behav2)
fs_new <- dplyr::select(behav2,site, focalID,focal_start_timeStamp,focal_end_timeStamp) 

fs_new<-unique(fs_new) #get focalIDs + date and time
fs_new$date <- substr(fs_new$focal_start_timeStamp, start=1, stop=10)
fs_new$starttime <- substr(fs_new$focal_start_timeStamp, start=12, stop=19)
fs_new$endtime <- substr(fs_new$focal_end_timeStamp, start=12, stop=19)


fs_new2<-flocksize #get flock sizes + date and time
fs_new2$obstime <- substr(fs_new2$time, start=12, stop=19)
fs_new2$date <- substr(fs_new2$date, start=1, stop=10)
fs_new2$dattime<-paste(fs_new2$date,fs_new2$obstime,sep=" ")

fs_new3<-dplyr::select(fs_new,site,focalstart=focal_start_timeStamp,focalID)
fs_new4<-dplyr::select(fs_new2,site,flockcount=dattime,WHIB_total)
fs_new4$flockcount <-as.POSIXct(fs_new4$flockcount,format="%Y-%m-%d %H:%M:%S")
fs_new3$focalstart <-as.POSIXct(fs_new3$focalstart,format="%Y-%m-%d,%H:%M:%S")

# coerce to data.table and append join columns to preserve the original columns 
setDT(fs_new3)
setDT(fs_new4)

fs_new3[, join_date := focalstart]
fs_new4[, join_date := flockcount]

setkey(fs_new3, site, join_date)
setkey(fs_new4, site, join_date)


flocksize.nearest<-fs_new4[fs_new3, roll = "nearest"]

#check to see if it worked: 
flocksize.nearest$flockdate <- substr(flocksize.nearest$flockcount, start=1, stop=10)
flocksize.nearest$followdate <- substr(flocksize.nearest$focalstart, start=1, stop=10)
flocksize.nearest$working<-flocksize.nearest$flockdate==flocksize.nearest$followdate #if any FALSE, not working 

##seems to be working just fine
ggplot(data=flocksize.nearest, aes(x=focalID, y=WHIB_total,fill=site)) +
  geom_bar(stat="identity")

```


```{r message=FALSE, warning=FALSE, include=FALSE}
#How are predictor and behavior variables distributed? 

#data = grouped_summary

#check to see if any of the behavior variables are normally distributed:
grouped.s<-spread(grouped_summary, key = act_type, value = prop.new)#convert to wide format
#grouped.s%>%
#  dplyr::select_if(is.numeric) %>% hist.data.frame() #clearly none of these are normally distributed 

#Create predictors data frame for ease of analysis
predictors <- indiv_ab2%>% dplyr::select(focalID,site,ToD,feedingperhour=no.people.per.hour)%>%unique()

#Add flock size data to predictor data frame:
#need to add date to focalID and then add it to predictors data frame
dates<-dplyr::select(indiv_ab2,date,focalID,site)
dates<-unique(dates)
predictors <- merge(predictors, dates, by=c("site", "focalID"))
flocksize.bydate<-unique(flocksize.bydate)
predictors <- merge(predictors, flocksize.bydate, by=c("site", "date"))
names(predictors)[names(predictors) == "size"] <- "avg_flock_size"

flocksize.nearest<-dplyr::select(flocksize.nearest,site,focalID,flocksize_nearest=WHIB_total)
predictors <- merge(predictors,flocksize.nearest, by=c("site", "focalID")) #153

#grouped.s <- merge(grouped.s, predictors, by="focalID") #merge data frames

##NEXT move on to one way comparisons between each behavior and site 
#head(grouped_summary)
#grouped_summary <- merge(grouped_summary, predictors, by="focalID")

#ggplot(grouped_summary, aes(x=site, y=prop.new)) + 
 # geom_boxplot() + facet_grid(.~act_type)

#ggplot(grouped_summary, aes(x=act_type, y=prop.new,color=act_type)) + 
 # geom_boxplot() + facet_grid(.~site) + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, #hjust=1))+scale_color_viridis(discrete=TRUE)


```

```{r include=FALSE}
fs_comparison<-dplyr::select(predictors,focalID,site,date,ToD,average=avg_flock_size,nearest=flocksize_nearest)
fs_comparison<-gather(fs_comparison, key = method, value = flocksize,5:6)

ggplot(data=fs_comparison, aes(x=focalID, y=flocksize,fill=method)) +
geom_bar(stat="identity", position=position_dodge())+theme_classic()

#1 means the two methods are equal
#below 1 means average was an underestimate
#above 1 means average was overestimate 
ggplot(data=predictors, aes(x=focalID, y=flocksize_nearest/avg_flock_size,fill=site)) +
geom_bar(stat="identity")+theme_classic()
```


```{r Re organize behavior data, message=FALSE, warning=FALSE, include=FALSE}
## Linear models for each behavior ~ site, people feeding, flock size
## Use glmmTMB with a negative binomial and then offset the model by the duration of a follow- e.g. don't use proportion data in this model

#restructure data in groups of relevant behaviors as counts rather than proportions 
#use 'summarizedData' data frame 

sumofActivityCounts <- aggregate(x=summarizedData$activityduration, #add activities types together by focal ID 
                                by=list(summarizedData$activity, summarizedData$focalID), #sum all all activity time counts by individual follow
                                FUN=sum) 
names(sumofActivityCounts)[names(sumofActivityCounts) == "Group.1"] <- "Activity" 
names(sumofActivityCounts)[names(sumofActivityCounts) == "Group.2"] <- "focalID" 
names(sumofActivityCounts)[names(sumofActivityCounts) == "x"] <- "activity_count" 


#add sites back in from 'behav3'
activityCounts_byindividual <- merge(sumofActivityCounts, behav3, by="focalID") #merge data frames 

#Data will look weird unless 0's are added to focal follows where certain behaviors do not occur
transposing <-spread(activityCounts_byindividual, key=Activity, value=activity_count, fill="0" )#spread the data to include 0's
activityCounts_byindividual2 <-melt(transposing, id.vars=c("focalID", "site","Observer")) #melt it back together in the correct format
names(activityCounts_byindividual2)[names(activityCounts_byindividual2) == "variable"] <- "Activity" #rename column
names(activityCounts_byindividual2)[names(activityCounts_byindividual2) == "value"] <- "activity_count" #rename column
activityCounts_byindividual2$activity_count <- as.numeric(activityCounts_byindividual2$activity_count)

#add back in duration from 'summarizedData'
head(summarizedData)
totaldurations <- dplyr::select(summarizedData, focalID,focalduration)
totaldurations <- unique(totaldurations)
activityCounts_byindividual2 <- merge(activityCounts_byindividual2, totaldurations, by="focalID")
dates<-dplyr::select(predictors, focalID,date)
dates<-unique(dates)
activityCounts_byindividual2 <- merge(activityCounts_byindividual2, dates, by="focalID")

#now this dataframe (activityCounts_byindividual2) can be used to run models
#will need to restructure once I collapse behaviors down but for now this will work

behaviorcounts<-activityCounts_byindividual2


fill_exposureWater <- function(x) { 
  if(x=="Foraging soil") y <- "Other"
  if(x=="Foraging water") y <- "WaterExposure"
  if(x=="Foraging HO") y <- "Other"
  if(x=="Foraging Hfood") y <- "Other"
  if(x=="Grooming Preening") y <- "Other"
  if(x=="Grooming Bathing") y <- "WaterExposure"
  if(x=="Disturbance Response Flush") y <- "Other"
  if(x=="Disturbance Response Retreat") y <- "Other"
  if(x=="Drinking NA") y <- "WaterExposure"
  if(x=="Flying NA") y <- "Other"
  if(x=="Loafing Asleep/Resting") y <- "Other"
  if(x=="Loafing Vigilant") y <- "Other"
  if(x=="Walking on HO") y <- "Other"
  if(x=="Walking on pavement") y <- "Other"
  if(x=="Walking on soil/grass") y <- "Other"
  return(y)
}

fill_HumanRisk <- function(x) { 
  if(x=="Foraging soil") y <- "Other"
  if(x=="Foraging water") y <- "Other"
  if(x=="Foraging HO") y <- "HumanRisk"
  if(x=="Foraging Hfood") y <- "HumanRisk"
  if(x=="Grooming Preening") y <- "Other"
  if(x=="Grooming Bathing") y <- "Other"
  if(x=="Disturbance Response Flush") y <- "Other"
  if(x=="Disturbance Response Retreat") y <- "Other"
  if(x=="Drinking NA") y <- "Other"
  if(x=="Flying NA") y <- "Other"
  if(x=="Loafing Asleep/Resting") y <- "Other"
  if(x=="Loafing Vigilant") y <- "Other"
  if(x=="Walking on HO") y <- "HumanRisk"
  if(x=="Walking on pavement") y <- "Other"
  if(x=="Walking on soil/grass") y <- "Other"
  return(y)
}

fill_Ectoparasite <- function(x) { 
  if(x=="Foraging soil") y <- "Other"
  if(x=="Foraging water") y <- "Other"
  if(x=="Foraging HO") y <- "Other"
  if(x=="Foraging Hfood") y <- "Other"
  if(x=="Grooming Preening") y <- "Ecto"
  if(x=="Grooming Bathing") y <- "Ecto"
  if(x=="Disturbance Response Flush") y <- "Other"
  if(x=="Disturbance Response Retreat") y <- "Other"
  if(x=="Drinking NA") y <- "Other"
  if(x=="Flying NA") y <- "Other"
  if(x=="Loafing Asleep/Resting") y <- "Other"
  if(x=="Loafing Vigilant") y <- "Other"
  if(x=="Walking on HO") y <- "Other"
  if(x=="Walking on pavement") y <- "Other"
  if(x=="Walking on soil/grass") y <- "Other"
  return(y)
}

fill_ForagePreen <- function(x) { 
  if(x=="Foraging soil") y <- "Foraging"
  if(x=="Foraging water") y <- "Foraging"
  if(x=="Foraging HO") y <- "Foraging"
  if(x=="Foraging Hfood") y <- "Foraging"
  if(x=="Grooming Preening") y <- "Preening"
  if(x=="Grooming Bathing") y <- "Preening"
  if(x=="Disturbance Response Flush") y <- "Other"
  if(x=="Disturbance Response Retreat") y <- "Other"
  if(x=="Drinking NA") y <- "Other"
  if(x=="Flying NA") y <- "Other"
  if(x=="Loafing Asleep/Resting") y <- "Other"
  if(x=="Loafing Vigilant") y <- "Other"
  if(x=="Walking on HO") y <- "Other"
  if(x=="Walking on pavement") y <- "Other"
  if(x=="Walking on soil/grass") y <- "Other"
  return(y)
}

fill_Vigilance <- function(x) { 
  if(x=="Foraging soil") y <- "Other"
  if(x=="Foraging water") y <- "Other"
  if(x=="Foraging HO") y <- "Other"
  if(x=="Foraging Hfood") y <- "Other"
  if(x=="Grooming Preening") y <- "Other"
  if(x=="Grooming Bathing") y <- "Other"
  if(x=="Disturbance Response Flush") y <- "Other"
  if(x=="Disturbance Response Retreat") y <- "Other"
  if(x=="Drinking NA") y <- "Other"
  if(x=="Flying NA") y <- "Other"
  if(x=="Loafing Asleep/Resting") y <- "Other"
  if(x=="Loafing Vigilant") y <- "Vigilant"
  if(x=="Walking on HO") y <- "Other"
  if(x=="Walking on pavement") y <- "Other"
  if(x=="Walking on soil/grass") y <- "Other"
  return(y)
}

fill_behav_simple <- function(x) { 
  if(x=="Foraging soil") y <- "Foraging"
  if(x=="Foraging water") y <- "Foraging"
  if(x=="Foraging HO") y <- "Foraging"
  if(x=="Foraging Hfood") y <- "Foraging"
  if(x=="Grooming Preening") y <- "Grooming"
  if(x=="Grooming Bathing") y <- "Grooming"
  if(x=="Disturbance Response Flush") y <- "Other"
  if(x=="Disturbance Response Retreat") y <- "Other"
  if(x=="Drinking NA") y <- "Drinking"
  if(x=="Flying NA") y <- "Other"
  if(x=="Loafing Asleep/Resting") y <- "Resting"
  if(x=="Loafing Vigilant") y <- "Vigilant"
  if(x=="Walking on HO") y <- "Walking"
  if(x=="Walking on pavement") y <- "Walking"
  if(x=="Walking on soil/grass") y <- "Walking"
  return(y)
}


behaviorcounts$WaterExposure <- sapply(behaviorcounts$Activity,fill_exposureWater) 
behaviorcounts$HumanExposureRisk <- sapply(behaviorcounts$Activity,fill_HumanRisk) 
behaviorcounts$EctoparasiteRisk <- sapply(behaviorcounts$Activity,fill_Ectoparasite) 
behaviorcounts$ForagePreen <- sapply(behaviorcounts$Activity,fill_ForagePreen) 
behaviorcounts$Vig <- sapply(behaviorcounts$Activity,fill_Vigilance) 
behaviorcounts$simple <- sapply(behaviorcounts$Activity,fill_behav_simple) 

#create new dataframes for each behavior type

WaterExposure <- dplyr::select(behaviorcounts, focalID,activity_count,focalduration,WaterExposure) #select relevant columns
WaterExposure <-WaterExposure  %>% 
  group_by(focalID, WaterExposure) %>% 
  summarise(activity_count = sum(activity_count, na.rm = TRUE))
WaterExposure_wide<-spread(WaterExposure, key = WaterExposure, value = activity_count)
WaterExposure_wide <- merge(predictors, WaterExposure_wide, by="focalID") #add in predictors 
WaterExposure_wide$duration <- WaterExposure_wide$Other+WaterExposure_wide$WaterExposure
WaterExposure_wide <- WaterExposure_wide[complete.cases(WaterExposure_wide), ]
water.int<-WaterExposure_wide$WaterExposure%%1==0 #check to confirm counts are integers
table(water.int)["FALSE"] #NA so no integers
table(water.int)["TRUE"] 


HumanExposureRisk <- dplyr::select(behaviorcounts, focalID,activity_count,focalduration,WaterExposure,HumanExposureRisk)
HumanExposureRisk <-HumanExposureRisk  %>% 
  group_by(focalID, HumanExposureRisk) %>% 
  summarise(activity_count = sum(activity_count, na.rm = TRUE))
HumanExposureRisk_wide<-spread(HumanExposureRisk, key = HumanExposureRisk, value = activity_count)
HumanExposureRisk_wide <- merge(predictors, HumanExposureRisk_wide, by="focalID") #add in predictors 
HumanExposureRisk_wide$duration <- HumanExposureRisk_wide$Other+HumanExposureRisk_wide$HumanRisk
HumanExposureRisk_wide <- HumanExposureRisk_wide[complete.cases(HumanExposureRisk_wide), ]


EctoparasiteRisk <- dplyr::select(behaviorcounts, focalID,activity_count,focalduration,WaterExposure,EctoparasiteRisk)
EctoparasiteRisk <-EctoparasiteRisk  %>% 
  group_by(focalID, EctoparasiteRisk) %>% 
  summarise(activity_count = sum(activity_count, na.rm = TRUE))
EctoparasiteRisk_wide<-spread(EctoparasiteRisk, key = EctoparasiteRisk, value = activity_count)
EctoparasiteRisk_wide <- merge(predictors, EctoparasiteRisk_wide, by="focalID") #add in predictors 
EctoparasiteRisk_wide$duration <- EctoparasiteRisk_wide$Other+EctoparasiteRisk_wide$Ecto
EctoparasiteRisk_wide <- EctoparasiteRisk_wide[complete.cases(EctoparasiteRisk_wide), ]
EctoparasiteRisk_wide$integer<-EctoparasiteRisk_wide$Ecto%%1==0 #check to confirm counts are integers
table(EctoparasiteRisk_wide$integer)["FALSE"] #NA no integers

ForagePreen<- dplyr::select(behaviorcounts, focalID,activity_count,focalduration,WaterExposure,ForagePreen)
ForagePreen <-ForagePreen  %>% 
  group_by(focalID, ForagePreen) %>% 
  summarise(activity_count = sum(activity_count, na.rm = TRUE))
ForagePreen_wide<-spread(ForagePreen, key = ForagePreen, value = activity_count)
ForagePreen_wide <- merge(predictors, ForagePreen_wide, by="focalID") #add in predictors 
ForagePreen_wide$duration <- ForagePreen_wide$Other+ForagePreen_wide$Foraging+ForagePreen_wide$Preening
ForagePreen_wide <- ForagePreen_wide[complete.cases(ForagePreen_wide), ]
forage.int<-ForagePreen_wide$Foraging%%1==0 #check to confirm counts are integers
table(forage.int)["FALSE"] #NA so no integers
ForagePreen_wide$integer<-ForagePreen_wide$Preening%%1==0 #check to confirm counts are integers
table(ForagePreen_wide$integer)["FALSE"] #NA no integers

Vig <- dplyr::select(behaviorcounts, focalID,activity_count,focalduration,Vig)
Vig <-Vig  %>% 
  group_by(focalID, Vig) %>% 
  summarise(activity_count = sum(activity_count, na.rm = TRUE))
Vig_wide<-spread(Vig, key = Vig, value = activity_count)
Vig_wide <- merge(predictors, Vig_wide, by="focalID") #add in predictors 
Vig_wide$duration <- Vig_wide$Other+Vig_wide$Vigilant
Vig_wide <- Vig_wide[complete.cases(Vig_wide), ]
Vig_wide$integer<-Vig_wide$Vigilant%%1==0 #check to confirm counts are integers
table(Vig_wide$integer)["FALSE"] #NA no integers

simplified_behaviors <- dplyr::select(behaviorcounts, focalID,activity_count,focalduration,simple)
simplified_behaviors  <-simplified_behaviors   %>% 
  group_by(focalID, simple) %>% 
  summarise(activity_count = sum(activity_count, na.rm = TRUE))
Simp_wide<-spread(simplified_behaviors, key = simple, value = activity_count)
Simp_wide <- merge(predictors, Simp_wide, by="focalID") #add in predictors 
Simp_wide$duration <- Simp_wide$Drinking+Simp_wide$Foraging+Simp_wide$Grooming+Simp_wide$Other+Simp_wide$Resting + Simp_wide$Vigilant+Simp_wide$Walking
Simp_wide <- Simp_wide[complete.cases(Simp_wide), ]
simp<-dplyr::select(Simp_wide, focalID,duration,Drinking,Foraging,Grooming,Resting,Vigilant,Walking,Other)

simp2<- simp %>% 
    rename("focalduration" = "duration")%>% 
  pivot_longer(
    cols = c(Drinking:Other),
    names_to = "Activity",
    values_to = "activity_count",
    values_drop_na = TRUE
  ) 

```

# Summary Statistics 

How many focal follows lasted > 2 minutes? *important- when we add in predictors later, we lose data for 3 follows because they lack corresponding predictor data.
```{r echo=FALSE}
#data frame = behaviorcounts 

sum1 <- Simp_wide
sum1 <- dplyr::select(sum1,focalID)
unique.IDs<-unique(sum1$focalID)
length(unique.IDs)

```

What was the total amount of time spent observing ibis? (this only includes obs >2 minutes aka the ones used in the analysis)

Total obs time in seconds:

```{r echo=FALSE}
sum2<-simp2
sum2<- dplyr::select(sum2,focalID, focalduration) %>% unique() 

sum(sum2$focalduration) #Total obs time in seconds

```

Total obs time in minutes:

```{r echo=FALSE}
sum(sum2$focalduration)/60 #Total obs time in minutes
```

Mean obs time:

```{r echo=FALSE}
mean(sum2$focalduration) #mean obs time in seconds
```

How many different behaviors were observed on average for each ibis during the observation?
```{r echo=FALSE}
#take behaviorcounts
#activity_count>0
#number of rows per focal ID
sum3<- as.data.frame(subset(simp2, activity_count > 0))


sum3.1 <- sum3 %>% group_by(focalID) %>% 
  summarise(n_behaviors=n(),
            .groups = 'drop')

summary(sum3.1)

```



How many birds showed 2 or more behaviors? 
```{r}
nrow(sum3.1[sum3.1$n_behaviors >= 2,]) #all birds observed for at least 2 minutes did 2 or more behaviors 

nrow(sum3.1[sum3.1$n_behaviors < 2,])
```

Most commonly observed behaviors observed? 

How many birds foraged?
```{r}
sum4 <- simp2

sum4f <- subset(sum4, Activity=="Foraging" & activity_count > 0)
summary(sum4f)

```

How many birds groomed?
```{r}
sum4g <- subset(sum4, Activity=="Grooming" & activity_count > 0)
summary(sum4g)

```

How many birds were vigilant?
```{r}
sum4v <- subset(sum4, Activity=="Vigilant" & activity_count > 0)
summary(sum4v)

```

What behaviors did ibis spend the most time doing?

```{r}
sum5<-simp2

sum5 <- sum5 %>% group_by(Activity) %>% summarise(sum(activity_count))
sum5

```
Which behaviors were observed most frequently in ibis?

```{r}
sum6<-simp2

sum6<- as.data.frame(subset(simp2, activity_count > 0))

sum6.1 <- sum6 %>% group_by(Activity) %>% 
  summarise(n_focals=n(),
            .groups = 'drop')

sum6.1

```

# Visualizations of predictors

**Predictors:**

* nearest flock size estimate
* feeding events per hour
* site? (not really interested in site-level differences per say but might help us understand if there are other inherent differences across sites that we aren't currently measuring) 

**What is the distribution of provisioning frequency? What about average flock size?** 
**Do we see any relationship between # feeding events and average flock size?**

Note: Here I'm showing avg flock size *and* nearest flock size

```{r echo=FALSE, message=FALSE, warning=FALSE}

###Visualize predictors
predictorsDATE <- unique(dplyr::select(predictors,site,date,feedingperhour,avg_flock_size))

ggplot(predictorsDATE, aes(x=feedingperhour)) + 
 geom_histogram()+
  labs(x="Feeding events per hour")

ggplot(predictorsDATE, aes(x=avg_flock_size)) + 
 geom_histogram()+
  labs(x="Average Flock Size")

ggplot(predictorsDATE, aes(x=feedingperhour, y=avg_flock_size)) + geom_point()+
  labs(x="Feeding events per hour", y = "Average flock size") + theme_classic()

ggplot(predictorsDATE, aes(x=feedingperhour, y=avg_flock_size, color=site, shape=site)) +
  geom_point() + geom_line()+
  labs(x="Feeding events per hour", y = "Average flock size") + theme_classic()

ggplot(predictors, aes(x=feedingperhour, y=flocksize_nearest, color=site, shape=site)) +
  geom_point() + geom_line()+
  labs(x="Feeding events per hour", y = "Nearest flock size") + theme_classic()

ggplot(predictorsDATE, aes(x=site, y=feedingperhour)) + 
  geom_boxplot()+geom_dotplot(binaxis='y', stackdir='center', dotsize=0.5,fill='#00CED1',color="black")+
  labs(title="Plot of feeding by site",x="Site", y = "Feeding events per hour")

ggplot(predictorsDATE, aes(x=site, y=avg_flock_size)) + 
  geom_boxplot()+geom_dotplot(binaxis='y', stackdir='center', dotsize=0.4,fill='#00CED1',color="black")+
  labs(title="Plot of average flock size by site",x="Site", y = "Daily Average Flock Size")

ggplot(predictors, aes(x=site, y=flocksize_nearest)) + 
  geom_boxplot()+geom_dotplot(binaxis='y', stackdir='center', dotsize=0.4,fill='#00CED1',color="black")+
  labs(title="Plot of nearest flock size by site",x="Site", y = "Nearest Flock Size")

```
# Provisioning and Flock Density

```{r}
ggplot(predictors, aes(x=feedingperhour, y=flocksize_nearest)) +
  geom_point() 

ggplot(predictors, aes(x=feedingperhour, y=log(flocksize_nearest))) +
  geom_point() 


lm1 <- lm(predictors$flocksize_nearest~predictors$feedingperhour)
summary(lm1)
```



# Model visualizations and Model Selection

Standardize predictor variables 

```{r}
#library(mosaic)  # standardizing variables

ForagePreen_wide <- 
  ForagePreen_wide %>% 
  mutate(avg_flock_size_s = scale(avg_flock_size))%>% 
  mutate(flocksize_nearest_s = scale(flocksize_nearest))%>%
  mutate(feedingperhour_s = scale(feedingperhour))

Vig_wide <- 
  Vig_wide %>% 
  mutate(avg_flock_size_s = scale(avg_flock_size))%>% 
  mutate(flocksize_nearest_s = scale(flocksize_nearest))%>%
  mutate(feedingperhour_s = scale(feedingperhour))
```


### Foraging models: 

**Main Q:**

Does flock size, provisioning, both, or neither influence foraging time?

Foraging includes foraging on soil, in water, on human objects, and consuming human provided food. 

Note: Focal follows were **only** conducted when people were not actively feeding the birds so foraging means probing on the ground for food. The few instances of consuming human provided food are cases where ibis were foraging 'naturally' and happened upon scraps of anthropogenic food that was already on the ground. 

**Exploratory Visualizations**

```{r echo=FALSE, message=FALSE, warning=FALSE}
hist(ForagePreen_wide$Foraging) #highly 0 inflated

ggplot(ForagePreen_wide, aes(x=flocksize_nearest, y=Foraging/duration)) +
  geom_point() +theme_classic() +
  labs(x="Nearest Flock Size", y = "Prop. of time foraging")

ggplot(ForagePreen_wide, aes(x=feedingperhour, y=Foraging/duration)) +
  geom_point() +theme_classic() +
  labs(x="Provisioning Frequency (# people feeding/hour)", y = "Prop. of time foraging")

ggplot(ForagePreen_wide, aes(x=site, y=Foraging/duration)) +
  geom_boxplot() +theme_classic() +
  labs(x="Site", y = "Prop. of time foraging")

ggplot(ForagePreen_wide, aes(x=flocksize_nearest_s, y=Foraging/duration)) +
  geom_point() +theme_classic() +
  labs(x="Nearest Flock Size (standardized)", y = "Prop. of time foraging")

ggplot(ForagePreen_wide, aes(x=feedingperhour_s, y=Foraging/duration)) +
  geom_point() +theme_classic() +
  labs(x="Provisioning Frequency (# people feeding/hour, standardized)", y = "Prop. of time foraging")

ggplot(ForagePreen_wide, aes(x=feedingperhour_s, y=flocksize_nearest_s)) + geom_point() +  labs(x="Feeding events per hour (standardized)", y = "Nearest flock size (standardized)") + theme_classic()

```

#### Model selection:

Count data: Does poisson or negative binomial fit better? Build global model (two predictors + interactions) and compare AIC. 

```{r}
pm1 = glmmTMB(Foraging~flocksize_nearest_s*feedingperhour_s + offset(log(duration)), ForagePreen_wide, family=poisson)

nbm1 = glmmTMB(Foraging~flocksize_nearest_s*feedingperhour_s  +offset(log(duration)), ForagePreen_wide, family=nbinom2)

zipm1 = glmmTMB(Foraging~flocksize_nearest_s*feedingperhour_s  +offset(log(duration)), zi=~flocksize_nearest_s*feedingperhour_s, ForagePreen_wide, family=poisson)

zipm1.int = glmmTMB(Foraging~flocksize_nearest_s*feedingperhour_s  +offset(log(duration)), zi=~1, ForagePreen_wide, family=poisson)

zinbm1 = glmmTMB(Foraging~flocksize_nearest_s*feedingperhour_s +offset(log(duration)), zi=~flocksize_nearest_s*feedingperhour_s, ForagePreen_wide, family=nbinom2)

zinbm1.int = glmmTMB(Foraging~flocksize_nearest_s*feedingperhour_s +offset(log(duration)), zi=~1, ForagePreen_wide, family=nbinom2) #intercept only zero inflated term (equally applies zero inflated to whole model)


AICtab(pm1,nbm1,zipm1,zipm1.int,zinbm1,zinbm1.int) #zinbm1.int is best fit 

```

Is this the case for other candidate models (not just the global model)?


```{r}

#just flock size
pm2 = glmmTMB(Foraging~flocksize_nearest_s + offset(log(duration)), ForagePreen_wide, family=poisson)

nbm2 = glmmTMB(Foraging~flocksize_nearest_s + offset(log(duration)), ForagePreen_wide, family=nbinom2)

zipm2 = glmmTMB(Foraging~flocksize_nearest_s + offset(log(duration)), zi=~flocksize_nearest_s, ForagePreen_wide, family=poisson)

zinbm2 = glmmTMB(Foraging~flocksize_nearest_s + offset(log(duration)), zi=~flocksize_nearest_s, ForagePreen_wide, family=nbinom2)

zinbm2.int = glmmTMB(Foraging~flocksize_nearest_s + offset(log(duration)), zi=~1, ForagePreen_wide, family=nbinom2)

AICtab(pm2,nbm2,zipm2,zinbm2,zinbm2.int) #the two zinbm models are the best 

#just provisioning
pm3 = glmmTMB(Foraging~feedingperhour_s + offset(log(duration)), ForagePreen_wide, family=poisson)

nbm3 = glmmTMB(Foraging~feedingperhour_s + offset(log(duration)), ForagePreen_wide, family=nbinom2)

zipm3 = glmmTMB(Foraging~feedingperhour_s + offset(log(duration)), zi=~feedingperhour_s, ForagePreen_wide, family=poisson)

zinbm3 = glmmTMB(Foraging~feedingperhour_s + offset(log(duration)), zi=~feedingperhour_s, ForagePreen_wide, family=nbinom2)

zinbm3.int = glmmTMB(Foraging~feedingperhour_s + offset(log(duration)), zi=~1, ForagePreen_wide, family=nbinom2)

AICtab(pm3,nbm3,zipm3,zinbm3,zinbm3.int) #the two zinbm models are the best

#Flock size and provisioning 
pm4 = glmmTMB(Foraging~flocksize_nearest_s+feedingperhour_s + offset(log(duration)), ForagePreen_wide, family=poisson)

nbm4 = glmmTMB(Foraging~flocksize_nearest_s+feedingperhour_s  +offset(log(duration)), ForagePreen_wide, family=nbinom2)

zipm4 = glmmTMB(Foraging~flocksize_nearest_s+feedingperhour_s  +offset(log(duration)), zi=~flocksize_nearest_s+feedingperhour_s, ForagePreen_wide, family=poisson)

zinbm4 = glmmTMB(Foraging~flocksize_nearest_s+feedingperhour_s +offset(log(duration)), zi=~flocksize_nearest_s+feedingperhour_s, ForagePreen_wide, family=nbinom2)

zinbm4.int = glmmTMB(Foraging~flocksize_nearest_s+feedingperhour_s +offset(log(duration)), zi=~1, ForagePreen_wide, family=nbinom2) #intercept only zero inflated term

AICtab(pm4,nbm4,zipm4,zinbm4,zinbm4.int) #the two zinbm models are the best 

```

Yes- the zero inflated models always outperform the others. 

I can also double check dispersion and zero inflation in my models using Dharma: 

```{r}

#check fit of poisson model: 
simulationOutput.pm1 <- simulateResiduals(fittedModel = pm1)
plot(simulationOutput.pm1)

#overdispersed or underdispersed?
testDispersion(simulationOutput.pm1,alternative = "greater") #test for overdispersion 
testDispersion(simulationOutput.pm1,alternative = "less") #test for underdispersion 
#poisson model is overdispersed 

#zero inflated?
testZeroInflation(simulationOutput.pm1) #yes zero inflated 

#Poisson model is overdispersed and zero inflated- will the neg binom model do better?
simulationOutput.nbm <- simulateResiduals(fittedModel = nbm1)
plot(simulationOutput.nbm)

#overdispersed or underdispersed?
testDispersion(simulationOutput.nbm,alternative = "greater") #test for overdispersion 
testDispersion(simulationOutput.nbm,alternative = "less") #test for underdispersion 
#This model is underdispersed

testZeroInflation(simulationOutput.nbm) #still slightly zero inflated 

#Now test a zero inflated neg binom model (look at zinbm1 and zinbm1.int)
simulationOutput.zinbm1 <- simulateResiduals(fittedModel = zinbm1)
plot(simulationOutput.zinbm1)

simulationOutput.zinbm1.int <- simulateResiduals(fittedModel = zinbm1.int)
plot(simulationOutput.zinbm1.int)

testDispersion(simulationOutput.zinbm1,alternative = "greater") #test for overdispersion 
testDispersion(simulationOutput.zinbm1,alternative = "less") #test for underdispersion 

testDispersion(simulationOutput.zinbm1.int,alternative = "greater") #test for overdispersion 
testDispersion(simulationOutput.zinbm1.int,alternative = "less") #test for underdispersion 

#disperson is fine for both of these, what about zero-inflation?
testZeroInflation(simulationOutput.zinbm1)
testZeroInflation(simulationOutput.zinbm1.int)

#Both of these models are good- no dispersion or zero inflation issues

```

These results suggest that the zero inflated models make the most sense (they fix the dispersion and zero inflation issues). ZI models with zi=1 and zi= conditional fixed effects are both sufficient in fixing these issues. 

For these data, I would think most zeros are false zeros that are due to experimental design AKA 0 foraging does not mean the bird never forages but rather it was not observed for long enough to observe foraging. I don't think these false zeros could be explained by my predictors. Because of this, I think I should apply a single zero inflation parameter to my entire model (ziformula~1). 

**Now I will move forward with zero inflated negative binomial models with a single zero inflated term applied to all models. **

First build models without any random effects: 

```{r}
#intercept only
fmod0.3 <-glmmTMB(Foraging~1+ offset(log(duration)),
                    family=nbinom2,
                    ziformula=~1,
                    data=ForagePreen_wide)
summary(fmod0.3)

#provisioning
fmod11 <-glmmTMB(Foraging~feedingperhour_s+offset(log(duration)),
                    family=nbinom2,
                    ziformula=~1,
                    data=ForagePreen_wide)
summary(fmod11)

#flock size
fmod12 <-glmmTMB(Foraging~flocksize_nearest_s+offset(log(duration)),
                    family=nbinom2,
                    ziformula=~1,
                    data=ForagePreen_wide)
summary(fmod12)

#provisioning + flock size
fmod13 <-glmmTMB(Foraging~flocksize_nearest_s+feedingperhour_s+offset(log(duration)),
                    family=nbinom2,
                    ziformula=~1,
                    data=ForagePreen_wide)
summary(fmod13)

fmod13.1 <-glmmTMB(Foraging~flocksize_nearest_s+feedingperhour_s+offset(log(duration)),
                    family=nbinom2,
                    ziformula=~1,
                    data=ForagePreen_wide)
summary(fmod13.1)

#provisioning x flock size 
fmod14 <-glmmTMB(Foraging~flocksize_nearest_s*feedingperhour_s+offset(log(duration)),
                    family=nbinom2,
                    ziformula=~1,
                    data=ForagePreen_wide)
summary(fmod14)

AICtab(fmod0.3,fmod11,fmod12,fmod13,fmod14)
```

fmod13 (flock size and feeding) and fmod14 (flock size * feeding) are best fitting models. 

Now build the same models but include site as a random effect and see if same models are best fitting. I think site makes sense biologically but it only has 4 levels so questionable as a RE. 

```{r}

#intercept only
fmod0.2 <-glmmTMB(Foraging~1+ (1|site) + offset(log(duration)),
                    family=nbinom2,
                    ziformula=~1,
                    data=ForagePreen_wide)
summary(fmod0.2)

#provisioning
fmod15 <-glmmTMB(Foraging~feedingperhour_s+(1|site)+offset(log(duration)),
                    family=nbinom2,
                    ziformula=~1,
                    data=ForagePreen_wide)
summary(fmod15)

#flock size
fmod16 <-glmmTMB(Foraging~flocksize_nearest_s+(1|site)+offset(log(duration)),
                    family=nbinom2,
                    ziformula=~1,
                    data=ForagePreen_wide)
summary(fmod16)

#provisioning + flock size
fmod17 <-glmmTMB(Foraging~flocksize_nearest_s+feedingperhour_s+(1|site)+offset(log(duration)),
                    family=nbinom2,
                    ziformula=~1,
                    data=ForagePreen_wide)
summary(fmod17)

#provisioning x flock size 
fmod18 <-glmmTMB(Foraging~flocksize_nearest_s*feedingperhour_s+(1|site)+offset(log(duration)),
                    family=nbinom2,
                    ziformula=~1,
                    data=ForagePreen_wide)
summary(fmod18)

AICtab(fmod0.2,fmod15,fmod16,fmod17,fmod18) #fmod17 and fmod18 = best fit
```

Models with flock size and feeding or flock size * feeding are still the best fitting models (fmod17 and fmod18 here).

Summary estimates aren't too different for the top performing models regardless of whether they include site as a random effect or not. 

#### Model diagnostics

##### Plotting predicted values: 

Plots made using ggeffects: https://strengejacke.github.io/ggeffects/index.html 

The ggeffects package computes estimated marginal means (predicted values) for the response, at the margin of specific values or levels from certain model terms, i.e. it generates predictions by a model by holding the non-focal variables constant and varying the focal variable(s).

First try this for the models that don't include random effects (fmod13 and fmod14)

```{r}
#predict(fmod13,ForagePreen_wide,se.fit=TRUE) #couold use predict fxn but ggpredict makes it easier to graph:

#just one variable in model
fmod13_predict <- ggpredict(fmod13, terms = "feedingperhour_s")
ggplot(fmod13_predict, aes(x, predicted)) +
  geom_line() +
  geom_ribbon(aes(ymin = conf.low, ymax = conf.high), alpha = .1)
plot(ggpredict(fmod13, terms = "feedingperhour_s"))

fmod13_predict2 <- ggpredict(fmod13, terms = c("feedingperhour_s","flocksize_nearest_s")) #both model terms

ggplot(fmod13_predict2, aes(x = x, y = predicted,color=group)) +
  geom_line() 
plot(fmod13_predict2)


#with interaction:
#note the interaction is not significant in this model

#just one variable in model
fmod14_predict <- ggpredict(fmod14, terms = "feedingperhour_s")
ggplot(fmod14_predict, aes(x, predicted)) +
  geom_line() +
  geom_ribbon(aes(ymin = conf.low, ymax = conf.high), alpha = .1)
plot(ggpredict(fmod14, terms = "feedingperhour_s"))

fmod14_predict2 <- ggpredict(fmod14, terms = c("feedingperhour_s","flocksize_nearest_s")) #both model terms

ggplot(fmod14_predict2, aes(x = x, y = predicted,color=group)) +
  geom_line() 
plot(fmod14_predict2)
```

The models look very similar for both fmod13 and fmod14. When you look at the model summary for fmod14, the interaction is not significant. The interaction adds another parameter to the model (this interaction is a 'pretending variable'). So they're both supported but fmod14 has more parameters.

Now try this for models with site as random effect (fmod17 and fmod18)

```{r}

#just one variable in model
fmod17_predict <- ggpredict(fmod17, terms = "feedingperhour_s")
ggplot(fmod17_predict, aes(x, predicted)) +
  geom_line() +
  geom_ribbon(aes(ymin = conf.low, ymax = conf.high), alpha = .1)
plot(ggpredict(fmod17, terms = "feedingperhour_s"))

fmod17_predict2 <- ggpredict(fmod17, terms = c("feedingperhour_s","flocksize_nearest_s")) #both model terms

ggplot(fmod17_predict2, aes(x = x, y = predicted,color=group)) +
  geom_line() 
plot(fmod17_predict2)

#with interaction:
#note the interaction is not significant in this model

#just one variable in model
fmod18_predict <- ggpredict(fmod18, terms = "feedingperhour_s")
ggplot(fmod14_predict, aes(x, predicted)) +
  geom_line() +
  geom_ribbon(aes(ymin = conf.low, ymax = conf.high), alpha = .1)

plot(ggpredict(fmod18, terms = "feedingperhour_s")) 
plot(ggpredict(fmod18, terms = "flocksize_nearest_s"))

fmod18_predict2 <- ggpredict(fmod18, terms = c("feedingperhour_s","flocksize_nearest_s")) #both model terms

ggplot(fmod18_predict2, aes(x = x, y = predicted,color=group)) +
  geom_line() 
plot(fmod18_predict2)
```

For the paper, showing model outputs for fmod17 (flock size + provisioning) might be useful. Choosing fmod17 because it doesn't include the interaction in fmod18 which isn't significant and does include site as random effect (as opposed to fmod13)

Make a 2 panel figure showing Foraging on Y axis and 1) provisioning and 2) flock size on X axis. 

```{r}
head(fmod17_predict) #data frame for provisioning
fmod17_predict3 <- ggpredict(fmod17, terms = "flocksize_nearest_s")
head(fmod17_predict3)

#merge these two dfs and then facet
#or just make each one pretty on it's own and paste together 

p1<-ggplot(fmod17_predict, aes(x, predicted)) +
  geom_line() +
  geom_ribbon(data=fmod17_predict,aes(ymin = conf.low, ymax = conf.high), alpha = .1)+xlab("Provisioning Frequency (standardized)") + ylab("Predicted Foraging Time")+ggtitle("flock_size + provisioning + (1 | site)")+theme_classic()

p2<-ggplot(fmod17_predict3, aes(x, predicted)) +
  geom_line() +
  geom_ribbon(data=fmod17_predict3,aes(ymin = conf.low, ymax = conf.high), alpha = .1)+xlab("Flock Size (standardized)") + ylab(NULL)+theme_classic()

p12<-grid.arrange(p1,p2,ncol=2)
ggsave("foragingmodeloutput.png",plot=p12)

#make a plot that includes raw data and shows model fit:
#data = ForagePreen_wide

p1_points<-ggplot(fmod17_predict, aes(x, predicted)) +
  geom_line() +
  geom_ribbon(aes(ymin = conf.low, ymax = conf.high), alpha = .2,fill='#440154')+xlab("Provisioning Frequency (standardized)") + ylab("Foraging Time (seconds)")+ggtitle("A).\n flock_size + provisioning + (1 | site)")+theme_classic()+geom_point(data=ForagePreen_wide, aes(x=feedingperhour_s, y=Foraging),color='#ABABAB')

p2_points<-ggplot(fmod17_predict3, aes(x, predicted)) +
  geom_line() +
  geom_ribbon(aes(ymin = conf.low, ymax = conf.high), alpha = .2,fill='#440154')+xlab("Flock Size (standardized)") + ylab("Foraging Time (seconds)")+ggtitle("B).")+theme_classic()+geom_point(data=ForagePreen_wide, aes(x=flocksize_nearest_s, y=Foraging),color='#ABABAB')

p12_points<-grid.arrange(p1_points,p2_points,ncol=2)
ggsave("foragingmodeloutput_points.png",plot=p12_points)

```

Make the same plots but without standardizing the predictor variables. 

```{r}
fmod17_unscaled <-glmmTMB(Foraging~flocksize_nearest+feedingperhour+(1|site)+offset(log(duration)),
                    family=nbinom2,
                    ziformula=~1,
                    data=ForagePreen_wide)
summary(fmod17)
summary(fmod17_unscaled) #p values look the same

fmod17_predict_unscaled <- ggpredict(fmod17_unscaled, terms = "feedingperhour")

fmod17_predict2_unscaled <- ggpredict(fmod17_unscaled, terms = "flocksize_nearest")

p1_points_unscaled<-ggplot(fmod17_predict_unscaled, aes(x, predicted)) +
  geom_line() +
  geom_ribbon(aes(ymin = conf.low, ymax = conf.high), alpha = .2,fill='#440154')+xlab("Provisioning Frequency") + ylab("Foraging Time (seconds)")+ggtitle("A).\n flock_size + provisioning + (1 | site)")+theme_classic()+geom_point(data=ForagePreen_wide, aes(x=feedingperhour, y=Foraging),color='#ABABAB')

p2_points_unscaled<-ggplot(fmod17_predict2_unscaled, aes(x, predicted)) +
  geom_line() +
  geom_ribbon(aes(ymin = conf.low, ymax = conf.high), alpha = .2,fill='#440154')+xlab("Flock Size") + ggtitle("B).")+ylab("Foraging Time (seconds)")+theme_classic()+geom_point(data=ForagePreen_wide, aes(x=flocksize_nearest, y=Foraging),color='#ABABAB')

p12_points_unscaled<-grid.arrange(p1_points_unscaled,p2_points_unscaled,ncol=2)
ggsave("foragingmodeloutput_points_unscaled.png",plot=p12_points_unscaled)

```


##### Diagnostics using Dharma

Testing the fit of fmod17 and fmod18- the two best fitting models that include site as a random effect. 

**First test the fit of fmod17**

```{r fmod17 diagnostics, echo=FALSE, message=TRUE, warning=TRUE}

summary(fmod17)
simulationOutput2 <- simulateResiduals(fittedModel = fmod17, n = 1000) 
plot(simulationOutput2) #left QQ plot residuals look fine, right plot looks ok too

#plot residuals against particular predictors
#predictors in fmod17 = flocksize_nearest_s and feedingperhour_s 
plotResiduals(simulationOutput2,ForagePreen_wide$feedingperhour_s) #not great
plotResiduals(simulationOutput2,ForagePreen_wide$flocksize_nearest_s) #not bad

#other goodness of fit metrics for residuals:
testDispersion(simulationOutput2) #no significant differences
testZeroInflation(simulationOutput2) #looks good
```

Residuals look fine. Plotting residuals against the two predictors suggests that there might be some issues for one of them. 

**Now test fit for fmod18**

```{r fmod18 diagnostics, echo=FALSE, message=TRUE, warning=TRUE}
summary(fmod18)
simulationOutput3 <- simulateResiduals(fittedModel = fmod18, n = 1000) 
plot(simulationOutput3)#left QQ plot residuals look fine, right plot looks ok too

#plot residuals against particular predictors
#predictors in fmod18 = flocksize_nearest_s and feedingperhour_s (and interaction but idt you can plot this)
plotResiduals(simulationOutput3,ForagePreen_wide$feedingperhour_s) #not great
plotResiduals(simulationOutput3,ForagePreen_wide$flocksize_nearest_s) #not as bad but still not great

#other goodness of fit metrics for residuals:
testDispersion(simulationOutput3) #no significant differences
testZeroInflation(simulationOutput3) #looks good
```

The residuals look pretty okay for this model too but there are more problems when I plot against specific predictors. 

#### Tables for Publication

```{r}
Cand.models <- list("null + (1|site)" =fmod0.2, 
                    "provisioning + (1|site)" = fmod15,
                    "flock size + (1|site)" = fmod16,
                    "provisioning + flock size + (1|site)" = fmod17,
                    "provisioning * flock size + (1|site)" = fmod18)
selectionTable <- aictab(cand.set = Cand.models, second.ord = FALSE) #uses AIC 
row.names(selectionTable) <- NULL

kable(selectionTable,col.names = c("Model","K","AIC"     ,  "$\\Delta$ AIC","ModelLik","AICWt", "LogLik","Cum.Wt"),caption = "<b>Foraging Candidate Models<b>") %>%
 kable_styling(latex_options = "striped") %>%
  kable_classic(  lightable_options = "striped",full_width = F, html_font = "Cambria")
```

```{r}
sf17<-summary(fmod17)
sumfmod17<-as.data.frame(sf17$coefficients[1])

kable(sumfmod17,col.names = c("Estimate","Std. error","z value","p-value"),caption = "<b>fmod17 summary<b>") %>%
 kable_styling(latex_options = "striped") %>%
  kable_classic(  lightable_options = "striped",full_width = F, html_font = "Cambria")

sf18<-summary(fmod18)
sumfmod18<-as.data.frame(sf18$coefficients[1])

kable(sumfmod18,col.names = c("Estimate","Std. error","z value","p-value"),caption = "<b>fmod18 summary<b>") %>%
 kable_styling(latex_options = "striped") %>%
  kable_classic(  lightable_options = "striped",full_width = F, html_font = "Cambria")


#try to merge these two summary tables 
sumfmod17$Model <- "fmod17"
sumfmod18$Model <- "fmod18"
sumfmod17$Predictors <- rownames(sumfmod17) #convert rownames to  column
sumfmod18$Predictors <- rownames(sumfmod18)#convert rownames to  column

fmods <- rbind(sumfmod17, sumfmod18)
rownames(fmods)<-NULL #remove rownames

fmods <- fmods %>%
  dplyr::select(Predictors, everything())

fmods$Model<-NULL
fmods <- fmods %>% 
       rename("pval" = "cond.Pr...z..") #renaming column 

#fmods$pval<-
 # dplyr::select(fmods,pval)%>% mutate_if(is.numeric, ~ case_when(. <0.00000001 ~ round(., 30), TRUE ~ round(.,5)))
#fmods <- fmods %>% 
   #    rename("pval" = "cond.Pr...z..") #renaming column 

#fmods  <- fmods  %>%
 # mutate(pval = case_when(
  # pval < 0.05 ~ paste0(as.character(pval), "*"),
  #  TRUE ~ paste0(pval)
 # ))

kable(fmods,col.names = c("Response/Predictors","Estimate","Std. error","z-value","p-value"),digits = c(5,5,5,5,20)) %>%
 kable_styling(latex_options = "striped") %>%
  kable_classic(  lightable_options = "striped",full_width = F, html_font = "Cambria")%>%
  pack_rows("Foraging", 1, 3) %>%
  pack_rows("Foraging", 4, 7)
```



### Grooming models: 

**Main Q:**

Does flock size, provisioning, both, or neither influence foraging time?

 Grooming includes preening or bathing. 
 
 **Exploratory Visualizations**
 
```{r echo=FALSE, message=FALSE, warning=FALSE}
hist(ForagePreen_wide$Preening) #highly 0 inflated

ggplot(ForagePreen_wide, aes(x=avg_flock_size, y=Preening/duration)) +
  geom_point() +theme_classic() +
  labs(x="Avg Flock Size", y = "Prop. of time Preening")

ggplot(ForagePreen_wide, aes(x=flocksize_nearest, y=Preening/duration)) +
  geom_point() +theme_classic() +
  labs(x="Nearest Flock Size", y = "Prop. of time Preening")

ggplot(ForagePreen_wide, aes(x=feedingperhour, y=Preening/duration)) +
  geom_point() +theme_classic() +
  labs(x="Provisioning Frequency (# people feeding/hour)", y = "Prop. of time Preening")

ggplot(ForagePreen_wide, aes(x=site, y=Preening/duration)) +
  geom_boxplot() +theme_classic() +
  labs(x="Site", y = "Prop. of time Preening")

```

##### Model selection:

Count data: Does poisson or negative binomial fit better? Build global model (two predictors + interactions) and compare AIC. 

```{r}
pm1_preen = glmmTMB(Preening~flocksize_nearest_s*feedingperhour_s + offset(log(duration)), ForagePreen_wide, family=poisson)

nbm1_preen = glmmTMB(Preening~flocksize_nearest_s*feedingperhour_s  +offset(log(duration)), ForagePreen_wide, family=nbinom2)

zipm1_preen = glmmTMB(Preening~flocksize_nearest_s*feedingperhour_s  +offset(log(duration)), zi=~1, ForagePreen_wide, family=poisson)

zinbm1_preen = glmmTMB(Preening~flocksize_nearest_s*feedingperhour_s +offset(log(duration)), zi=~1, ForagePreen_wide, family=nbinom2)


AICtab(pm1_preen,nbm1_preen,zipm1_preen,zinbm1_preen) #zero inflated is best here, continue with this model

```

Zero inflated negative binomial model is the best one so continue with that model structure. 
 
```{r}


##No random effects: 

#intercept only
pmod0.3 <-glmmTMB(Preening~1+ offset(log(duration)),
                    family=nbinom2,
                    ziformula=~1,
                    data=ForagePreen_wide)
summary(pmod0.3)

#provisioning
pmod11 <-glmmTMB(Preening~feedingperhour_s+offset(log(duration)),
                    family=nbinom2,
                    ziformula=~1,
                    data=ForagePreen_wide)
summary(pmod11)

#flock size
pmod12 <-glmmTMB(Preening~flocksize_nearest_s+offset(log(duration)),
                    family=nbinom2,
                    ziformula=~1,
                    data=ForagePreen_wide)
summary(pmod12)

#provisioning + flock size
pmod13 <-glmmTMB(Preening~flocksize_nearest_s+feedingperhour_s+offset(log(duration)),
                    family=nbinom2,
                    ziformula=~1,
                    data=ForagePreen_wide)
summary(pmod13)

#provisioning x flock size 
pmod14 <-glmmTMB(Preening~flocksize_nearest_s*feedingperhour_s+offset(log(duration)),
                    family=nbinom2,
                    ziformula=~1,
                    data=ForagePreen_wide)
summary(pmod14)

AICtab(pmod0.3,pmod11,pmod12,pmod13,pmod14)

##Same models but with site as random effect 
#intercept only
pmod0.2 <-glmmTMB(Preening~1+ (1|site) + offset(log(duration)),
                    family=nbinom2,
                    ziformula=~1,
                    data=ForagePreen_wide)
summary(pmod0.2)

#provisioning
pmod15 <-glmmTMB(Preening~feedingperhour_s+(1|site)+offset(log(duration)),
                    family=nbinom2,
                    ziformula=~1,
                    data=ForagePreen_wide)
summary(pmod15)

#flock size
pmod16 <-glmmTMB(Preening~flocksize_nearest_s+(1|site)+offset(log(duration)),
                    family=nbinom2,
                    ziformula=~1,
                    data=ForagePreen_wide)
summary(pmod16)

#provisioning + flock size
pmod17 <-glmmTMB(Preening~flocksize_nearest_s+feedingperhour_s+(1|site)+offset(log(duration)),
                    family=nbinom2,
                    ziformula=~1,
                    data=ForagePreen_wide)
summary(pmod17)

#provisioning x flock size 
pmod18 <-glmmTMB(Preening~flocksize_nearest_s*feedingperhour_s+(1|site)+offset(log(duration)),
                    family=nbinom2,
                    ziformula=~1,
                    data=ForagePreen_wide)
summary(pmod18)

AICtab(pmod0.2,pmod15,pmod16,pmod17,pmod18)

```

The top performing models are within 2 AIC values of the intercept only null model. 

#### Model diagnostics

Not needed because the intercept only model is the best fitting model?

#### Tables for Publication

```{r}
Cand.models_groom <- list("null + (1|site)" =pmod0.2, 
                    "provisioning + (1|site)" = pmod15,
                    "flock size + (1|site)" = pmod16,
                    "provisioning + flock size + (1|site)" = pmod17,
                    "provisioning * flock size + (1|site)" = pmod18)
selectionTable_groom <- aictab(cand.set = Cand.models_groom, second.ord = FALSE) #uses AIC 
row.names(selectionTable_groom) <- NULL

kable(selectionTable_groom,col.names = c("Model","K","AIC"     ,  "$\\Delta$ AIC","ModelLik","AICWt", "LogLik","Cum.Wt"),caption = "<b>Grooming Candidate Models<b>") %>%
 kable_styling(latex_options = "striped") %>%
  kable_classic(  lightable_options = "striped",full_width = F, html_font = "Cambria")
```



### Vigilance models:

**Main Q:**

Does flock size, provisioning, both, or neither influence vigilance time?

 **Exploratory Visualizations**
 
```{r echo=FALSE, message=FALSE, warning=FALSE}
hist(Vig_wide$Vigilant) #highly 0 inflated

ggplot(Vig_wide, aes(x=avg_flock_size, y=Vigilant/duration)) +
  geom_point() +theme_classic() +
  labs(x="Avg Flock Size", y = "Prop. of time Vigilant")

ggplot(Vig_wide, aes(x=flocksize_nearest, y=Vigilant/duration)) +
  geom_point() +theme_classic() +
  labs(x="Nearest Flock Size", y = "Prop. of time Vigilant")

ggplot(Vig_wide, aes(x=feedingperhour, y=Vigilant/duration)) +
  geom_point() +theme_classic() +
  labs(x="Provisioning Frequency (# people feeding/hour)", y = "Prop. of time Vigilant")

ggplot(Vig_wide, aes(x=site, y=Vigilant/duration)) +
  geom_boxplot() +theme_classic() +
  labs(x="Site", y = "Prop. of time Vigilant")

```

##### Model selection:

Count data: Does poisson or negative binomial fit better? Build global model (two predictors + interactions) and compare AIC. 

```{r}
pm1_vig = glmmTMB(Vigilant~flocksize_nearest_s*feedingperhour_s + offset(log(duration)), Vig_wide, family=poisson)

nbm1_vig = glmmTMB(Vigilant~flocksize_nearest_s*feedingperhour_s  +offset(log(duration)), Vig_wide, family=nbinom2)

zipm1_vig = glmmTMB(Vigilant~flocksize_nearest_s*feedingperhour_s  +offset(log(duration)), zi=~1, Vig_wide, family=poisson)

zinbm1_vig = glmmTMB(Vigilant~flocksize_nearest_s*feedingperhour_s +offset(log(duration)), zi=~1, Vig_wide, family=nbinom2)


AICtab(pm1_vig,nbm1_vig,zipm1_vig,zinbm1_vig) #zero inflated is best here, continue with this model

```

Zero inflated negative binomial model is the best one so continue with that model structure. 
 
```{r}

##No random effects: 

#intercept only
vmod0.3 <-glmmTMB(Vigilant~1+ offset(log(duration)),
                    family=nbinom2,
                    ziformula=~1,
                    data=Vig_wide)
summary(vmod0.3)

#provisioning
vmod11 <-glmmTMB(Vigilant~feedingperhour_s+offset(log(duration)),
                    family=nbinom2,
                    ziformula=~1,
                    data=Vig_wide)
summary(vmod11)

#flock size
vmod12 <-glmmTMB(Vigilant~flocksize_nearest_s+offset(log(duration)),
                    family=nbinom2,
                    ziformula=~1,
                    data=Vig_wide)
summary(vmod12)

#provisioning + flock size
vmod13 <-glmmTMB(Vigilant~flocksize_nearest_s+feedingperhour_s+offset(log(duration)),
                    family=nbinom2,
                    ziformula=~1,
                    data=Vig_wide)
summary(vmod13)

#provisioning x flock size 
vmod14 <-glmmTMB(Vigilant~flocksize_nearest_s*feedingperhour_s+offset(log(duration)),
                    family=nbinom2,
                    ziformula=~1,
                    data=Vig_wide)
summary(vmod14)

AICtab(vmod0.3,vmod11,vmod12,vmod13,vmod14)

##Same models but with site as random effect 
#intercept only
vmod0.2 <-glmmTMB(Vigilant~1+ (1|site) + offset(log(duration)),
                    family=nbinom2,
                    ziformula=~1,
                    data=Vig_wide)
summary(vmod0.2)

#provisioning
vmod15 <-glmmTMB(Vigilant~feedingperhour_s+(1|site)+offset(log(duration)),
                    family=nbinom2,
                    ziformula=~1,
                    data=Vig_wide)
summary(vmod15)

#flock size
vmod16 <-glmmTMB(Vigilant~flocksize_nearest_s+(1|site)+offset(log(duration)),
                    family=nbinom2,
                    ziformula=~1,
                    data=Vig_wide)
summary(vmod16)

#provisioning + flock size
vmod17 <-glmmTMB(Vigilant~flocksize_nearest_s+feedingperhour_s+(1|site)+offset(log(duration)),
                    family=nbinom2,
                    ziformula=~1,
                    data=Vig_wide)
summary(vmod17)

#provisioning x flock size 
vmod18 <-glmmTMB(Vigilant~flocksize_nearest_s*feedingperhour_s+(1|site)+offset(log(duration)),
                    family=nbinom2,
                    ziformula=~1,
                    data=Vig_wide)
summary(vmod18)

AICtab(vmod0.2,vmod15,vmod16,vmod17,vmod18)

```

The top performing models are within 2 AIC values of the intercept only null model. 

#### Model diagnostics

Not needed because the intercept only model is the best fitting model? 

#### Tables for Publication

```{r}
Cand.models_vig <- list("null + (1|site)" =vmod0.2, 
                    "provisioning + (1|site)" = vmod15,
                    "flock size + (1|site)" = vmod16,
                    "provisioning + flock size + (1|site)" = vmod17,
                    "provisioning * flock size + (1|site)" = vmod18)
selectionTable_vig <- aictab(cand.set = Cand.models_vig, second.ord = FALSE) #uses AIC 
row.names(selectionTable_vig) <- NULL

kable(selectionTable_vig,col.names = c("Model","K","AIC"     ,  "$\\Delta$ AIC","ModelLik","AICWt", "LogLik","Cum.Wt"),caption = "<b>Vigilance Candidate Models<b>") %>%
 kable_styling(latex_options = "striped") %>%
  kable_classic(  lightable_options = "striped",full_width = F, html_font = "Cambria")
```

